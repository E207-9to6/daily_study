# IPv4(Internet Protocol version 4)

## IPv4 Datagram 포맷
![image](https://github.com/E207-9to6/daily_study/assets/68316096/d6d8ed46-3f7d-4e56-88ac-fabfa317fede)  
- `version`: IP프로토콜의 버전을 의미하며 4비트로 설정됨

- `header length`: 옵션 필드를 포함한 헤더의 총 길이를 나타냄(옵션의 길이는 0~40byte, 가변적)

- `total length`: 전체 길이 필드의 길이는 16비트이므로 IP패킷의 최대 크기는 2^16 - 1인 65,535바이트가 된다.

- `identification number`: 링크의 최대 전달 유닛(MTU, Maximum Transmission Unit)보다 더 큰 데이터를 보내기 위해 여러 개의 패킷으로 분할할 경우, 목적지에서 재조립을 위해 사용하는 필드로 분할된 패킷들은 같은 식별자 값을 갖는다.
  + IP 프로토콜에서는 상위 계층에서 내려온 전송 데이터가 패킷 하나로 전송하기에 너무 크면 분할해서 전송한다.

- `flags`: 단편화 여부나 단편화된 필드가 몇 번째 조각인지 구분하기 위해 사용하는 필드

- `fragment offset`: 패킷 재조립 시 분할된 패킷 간 순서 정보를 저장

- `time to live(TTL)`: 패킷이 경유할 수 있는 최대 홉 수. 패킷이 라우터를 통과할 때마다 TTL 값은 1씩 감소되며, TTL 값이 0이 되면 패킷은 폐기되고 송신 측으로 ICMP 메시지가 전달됨
  + `ICMP`: ICMP(Internet Control Message Protocol)는 TCP/IP에서 IP 패킷을 처리할 때 발생한 문제를 알려주는 프로토콜

- `header checksum`: IP 패킷 헤더의 오류 발생을 검사하기 위한 필드

## 특징
- IPv4 주소는 32비트. 8바트 단위로 나누어 `.`으로 구분하고 10진수로 나타낸다.

- IPv4 주소는 해당 네트워크를 구분하기 위한 네트워크 ㅈ소와 호스트 주소로 구성됨

- 네트워크와 호스트의 주소 개수에 따라 다섯 개의 클래스(A, B, C, D, E)로 구분함

## 클래스 분류
![image](https://github.com/E207-9to6/daily_study/assets/68316096/23613ee5-2599-491f-bca0-059a4fb376ff)   
### `클래스 A (0.0.0.0 ~ 127.255.255.255)`
+ 첫 번째 비트가 `0`인 주소
+ 첫 바이트가 네트워크 주소, 하위 세 바이트는 호스트 주소
+ 2^24- 2 = 16,777,214 개의 호스트를 수용할 수있기 때문에 큰 규모의 호스트를 갖는 기관에서 사용  
 
### `클래스 B (128.0.0.0 ~ 191.255.255.255)`
+ 처음 두 비트 값이 `10`인 주소
+ 첫번째 바이트의 나머지 6비트, 두 번째 바이트가 네트워크 주소, 마지막 두 바이트가 호스트 주소
+ 2^16 - 2개의 호스트 수용 가능  

### `클래스 C (192.0.0.0 ~ 223.255.255.255)`
+ 처음 세 비트 값이 `110`인 주소
+ 네트워크마다 254개 호스트 수용 가능

### `클래스 D (224.0.0.0 ~ 239.255.255.255)`
+ 처음 네 비트 값이 `1110`인 주소
+ 네트워크 주소와 호스트 주소의 구분이 없고 전체 주소가 멀티캐스트용으로 사용됨
 
### `클래스 E (240.0.0.0 ~ 255.255.255.255)`
+ 처음 네 비트 값이 `1111`인 주소
+ 추후 사용을 위해 예약된 주소

## 특수한 IP 주소
- 네트워크 주소: 네트워크 자체를 의미하며 호스트 식별자 필드를 모두 0으로 설정한 주소
  + 패킷의 송신지나 수신지 주소로 사용 불가

- 브로드캐스트 주소: 호스트 주소의 모든 비트가 1인 주소
  + 네트워크에 있는 모든 호스트로 패킷을 보낼 때 사용
 
- 루프백 주소: localhost, 자기 자신을 가리키기 위한 목적으로 사용되기 위해 예약된 IP주소
  + 보통 127.0.0.1
 
## IPv4 전송 방법 분류
1. 유니캐스트: one to one

2. 멀티캐스트: one to many 패킷 전송, 특정 다수인에게 전송. 그룹에 가입된 호스트에게만 패킷을 보내는 방식

3. 브로드캐스트: one to many, 불특정 다수인에게 전송. 같은 네트워크에 있는 모든 호스트에게 패킷을 보내는 방식

## 주소 관리 방식
### 1. 서브네팅
- 하나의 큰 네트워크를 몇 개의 작은 논리적인 네트워크로 분할하여 사용하는 방식  
 
- 서브넷마스크(subnet mask)로 IP주소의 네트워크 주소와 호스트 주소를 구분할 수 있다.
 
- 서브넷마스크와 IP주소를 and 연산하면 네트워크 주소를 알 수 있다
 
- 예시)
  ![image](https://github.com/E207-9to6/daily_study/assets/68316096/50de18b8-1676-4644-b8dd-0af1b3370343)
  + 기존 B클래스의 디폴트 서브넷 마스크(255.255.0.0)을 사용할 경우
    + 2^16 개의 네트워크로 구분하여 각 네트워크 당 2^16-2개의 호스트를 사용할 수 있음

  + 다른 서브넷 마스크(255.255.255.0)을 사용하여 서브네팅 할 경우
    + 2^24 개의 네트워크로 구분하여 각 네트워크 당 2^8-2개의 호스트를 사용할 수 있음

 - 장점
   + 브로드캐스트 영역 크기를 작게 만들 수 있음
   + 한 네트워크에 연결된 호스트 수를 줄여 라우팅 테이블 크기를 줄일 수 있음

### 2. 슈퍼네팅
- 서브네팅의 반대 개념
  
- 부족한 IP를 효율적으로 사용하기 위해 여러 개의 C 클래스 주소를 묶어 하나의 네트워크로 구성하는 방식

- 예시)
  ![image](https://github.com/E207-9to6/daily_study/assets/68316096/510f5d55-d707-45e3-b3cb-8994cbddbb38)
  + 3비트의 호스트가 추가로 필요, 슈퍼넷 마스크는 255.255.248.0이 되어 11비트를 호스트 주소로 사용할 수 있다.

### 3. CIDR(Classless Inter-Domain Routing)
- 클래스별로 IP주소를 구분하지 않는 방법

- class 체계보다 더 유연하게 IP주소를 여러 네트워크 영역으로 나눌 수 있음

- IP 주소의 낭비를 방지하고 효과적으로 네트워크 구성 가능

- `192.168.10.0/24` => 상위 24비트가 네트워크 주소이며 하위 8비트는 호스트 주소

- `143.7.65.203/23` 주소에서 사용 가능한 대역은?
  + 이진수로 표현, 네트워크 주소와 호스트 주소 구분: `10001111 00000111 0100000/1 11001011`
  + `10001111 00000111 0100000/0 00000000` ~ `10001111 00000111 0100000/1 11111111`
  + == `143.7.64.0` ~ `143.7.65.255` 
